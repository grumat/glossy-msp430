# <big>STM32 Clock Tree</big>

These template classes provide access to the clock tree of selected STM32 
MCUs. The clock tree differs for each MCU family, so you have to follow 
the User's Guide for configurations supported by your hardware.

> These template classes are only type definitions. No instance are 
> required. Methods are all static.

A good example is here:

```cpp
using namespace Bmt;

// 8 MHz crystal
constexpr uint32_t kMyXtal = 8000000UL;
// 80 MHz desired SYSCLK
constexpr uint32_t kMySysClk = 80000000UL;

// The HSE drives the XTAL
typedef Clocks::AnyHse<kMyXtal> Hse;
// Calculator for PLLCLK/SYSCLK
typedef Clocks::Range1 PllCalculator;
// The Pll uses Hse and Calculator to obtain 72MHz
typedef Clocks::AnyPll<
    Hse,                // clock source used for the PLL
    kMySysClk,          // desired PLL output
    PllCalculator,      // calculator to obtain '/M', '/N' and '/R'
    > Pll;

typedef Clocks::AnySysClk<
    Pll,                // Uses the PLL as system clock
    AhbPrscl::k1,       // No divisor for thw AHB bus
    ApbPrscl::k2,       // 40 MHz for the APB1 bus
    ApbPrscl::k1,       // 80 MHz for the APB2 bus
    > SysClk;

void main()
{
    // ...

    // This starts HSE, then setups and starts PLL and initializes the 
    // clock tree
    SysClk::Init();

    // ...
}
```




# General Rules for the Clock Classes

All classes from this domain are accesses through the `Bmt::Clocks` 
name-space.

```cpp
using namespace Bmt;

typedef Clocks::Hse<> Hse; // ...etc...
```

or

```cpp
using namespace Bmt::Clocks;

typedef Hse<> MyHse; // Naming *conflicts* may happen...
```

> In general it is recommended the first form, as the "`Clocks::...`" scope 
> will reduce conflicts with common STM32 names.

In general a MCU will have clock circuits like the HSI, HSE, LSI, LSE and 
probably at least one PLL.

This name-space will offer at least one template class for each available 
clock circuit. For example, on the STM32F103 family, the following 
classes are available for each clock circuit:

| Class    | Description                                                | 
|----------|------------------------------------------------------------| 
| `AnyHsi` | A template class responsible to configure the HSI with a specified trim value. |
| `AnyHse` | A template class responsible to configure the HSE with a set of parameters.|
| `AnyLse` | A template class responsible to configure the LSE with a set of parameters.|
| `AnyLsi` | A template class that represents the LSI clock instance.   | 
| `PllVco` | A template class with a PLL ratio calculator.              |
| `AnyPll` | A template class to configure the PLL with given parameters. |
| `AnySycClk` | A template class to configure the clock tree and buses. |
| `AnyUsbSycClk` | A derivative of `AnySycClk` tailored for USB applications. |

Apart from the last two classes, which binds clocks sources and 
establishes a setup for all clock buses, all other clock classes will 
contain at least one of the following members described in the next 
subtopics. 


## The `kClockSource_` Member

This is an ID indicating the clock generator. This value is defined in 
the `enum Id` and varies according to the MCU family. The identifier 
allows other classes to verify if this clock source is supported.  
For example, the PLL can only be sourced by the HSI or HSE clock. Other 
combinations will stop compilation because a `static_assert()` will 
ensure that an invalid clock source cannot be chained with the PLL.


## The `kFrequency_` Member

The frequency generated by this clock source. Some clock sources have 
fixed frequency, others depends on configuration parameters and for 
chained clock circuits, like the PLL, from the frequency of this source 
and configuration parameters, computed internally by the library.

> Note that since we are configuring hardware, a configuration has only 
> constant values or parameters.  The frequencies are obtained from 
> values declared on the data-sheet regardless of component tolerance or 
> trimming values. 


## The `kClockInput_` Member

For independent clock sources this is exactly the same value as 
`kClockSource_`, meaning its input is generated by an internal 
dedicated circuit. 

But if the clock is connected in chain with another source, this value is 
the `Id` of this source input, so we are able to track how this chain is 
configured.


## The `Init()` Method

This method is provided by all clock sources and is used to initialize a 
clock circuit for the first time, typically when a firmware boots.

For the most cases this method just calls the `Enable()` method. An 
exception to this rule is when a clock is chained like the PLL, the proper 
`Init()` from the attached source is called implicitly, so you are not 
required to write multiple `Init()` lines.

Example:
```cpp
using namespace Bmt;

// The HSE clock has a 8MHz crystal soldered on the board
typedef Clocks::AnyHse<8000000UL> HSE;

void main()
{
    // ... Init other stuff ...

    // Starts the crystal
    HSE::Init();

    // ... etc ...
}
```


## The `Enable()` Method

The `Enable()` method is exactly like the `Init()` method with the 
exception that chained clocks are not changed. This means that for most 
clock circuits they are exactly the same.

> As a general rule of thumb you will use the `Init()` during firmware 
> initialization and `Enable()` in normal device use.


## The `Disable()` Method

The `Disable()` method is used to disable the clock circuit, exactly as 
the name suggests.

Please note that it is important to ensure that no peripheral or CPU 
depends on the clock signal you are disabling, or you may stall your 
device.


# The `AnyHsi<>`/`AnyHsi16<>` template class

The HSI is an internal clock, used as primary clock when a device boots. 
It is typically imprecise, because it is based on an RC circuit which is 
not stable enough for applications that required timing accuracy, like 
USB. 

> Possibly all STM32 devices implements an HSI clock, whereas the L4xx 
> also implements an MSI clock. Normally HSI is used during boot 
> processes, but in devices having MSI this is not the case. Details on 
> device-specific data-sheet.

This circuit offers a trimming adjustment which can be defined as an 
template argument in the class definition to specify the default 
calibration.  
When instantiating the template without an argument the factory default 
trimming value is used.

The example below assumes that the HSI is already running (as part of the 
boot process), but lets one change the trimming value:
```cpp
using namespace Bmt;

void TrimHsi(uint8_t val)
{
    // Changes the trim value
    Clocks::AnyHsi<>::Trim(val);
}
```

Other methods like `AnyHsi<>::Init()`, `AnyHsi<>::Enable()` and 
`AnyHsi<>::Disable()` are available. The last one is probably the most 
important one, when one drives the SYSCLK with an external crystal
(i.e. `AnyHse<>` template) and wants to disable the HSI to save energy. 


# The `AnyMsi<>` template class

MSI stands for *Multi Speed Internal* clock.  
This class happens only on some family members, when the MSI clock is 
available. This clock source offers additional features when compared to 
the HSI clock.

> When the MCU features the MSI clock it is also the default clock source 
> used after reset and starts typically at 4 MHz.

This template has the following parameters:
- `kFreqCR`: This enumeration allows one to select one of the predefined 
clock frequencies in the range of 100 kHz up to 48 MHz.
- `kPllMode`: This flag activates a very useful feature of this clock 
circuit, which is a PLL controlled by the LSE clock. This configuration 
enhances the stability and accuracy of this clock source, enabling 
support for USB communication.

Example:

```cpp
using namespace Bmt;

// LSE using standard 32768 XTAL
typedef Clocks::AnyLSE<> LSE;
// MSI 48 MHz using PLL feature
typedef Clocks::AnyMSI<Clocks::MsiFreq::k48_MHz, true> MSI;
// System clock driven by MSI
typedef Clocks::AnySycClk<MSI> SYSCLK;

void main()
{
    // ...

    // Initializes the 32768 XTAL
    LSE::Init();
    // Now that LSE is running, initializes and run system 
    // with MSI at 48 MHz clock
    SYSCLK::Init();

    // ...
}
```

Note that the configuration show above assumes that hardware contains a
32.768 kHz crystal soldered to the LSE clock pins.  
The example initializes the LSE first before initializing the clock tree. 
The clock tree is represented by `AnySysClk<>`, which is documented 
later on this document. The clock tree internally calls `MSI::Init()` 
to initialize the MSI; this is possible since it is part of `AnySysClk<>` 
declaration.


# The `AnyHse<>` template class

This class is responsible for configuring the HSE clock. The HSE clock
is the *High Speed External Clock*, which contains an external crystal as 
timing reference and is generally recommended when time base must be 
exact.

The template class accepts 3 arguments:
- `kFrequency`: Is the frequency of the crystal and is defined by your 
hardware design. Typical values are 8 or 16 MHz, which should be typed 
in Hz literally.
- `kBypass`: Is a flag that indicates if the circuit uses bypass mode. 
This is also defined by your hardware design and indicates that other 
device is providing the clock in a dedicated input pin. It also means 
that the active part of the clock circuit is turned off.
- `kCssEnabled`: Enables the *Clock Security Feature*. Check data-sheet 
for usage details.

Example:

```cpp
using namespace Bmt;

// HSE clock generator has as 12 MHz XTAL
typedef Clocks::AnyHSE<12000000UL> HSE;
typedef Clocks::AnySycClk<HSE  // Turns HSE into main clock
    , Power::Mode::kRange1     // remove this line for STMF1xx
    > SYSCLK;
void main()
{
    // ...

    // Initializes and run system with HSE 12 MHz clock
    SYSCLK::Init();
}
```


# PLL Calculators &ndash; The `Private::AnyPllVco<>` Base Template Class and it's Overrides

The `Private::AnyPllVco<>` template class is a very generic template 
class used by each individual MCU variation to compute PLL frequencies. 
It accepts a series of template parameters with the hardware constraints 
for each PLL implementation. 

This model fits a PLL that follows the formula:
```cpp
F_out = (F_in / M) * N;
```

In words, the input frequency is first divided by **M** and then 
multiplied by **N** to produce the output frequency.  
All template parameters have to meet data-sheet specs, given as the 
following:

- `kVcoInMin`: The minimum allowed input frequency
- `kVcoInMax`: The maximum allowed input frequency
- `kVcoOutMin`: The minimum allowed output frequency
- `kVcoOutMax`: The maximum allowed output frequency
- `kN_Min`: The minimum allowed multiplier
- `kN_Max`: The maximum allowed multiplier
- `kM_Min`: The minimum allowed divisor
- `kM_Max`: The maximum allowed divisor

You don't have to bother with these parameters. Each specific target 
will specify overrides for you, with values in accordance to the 
User's Guide. 

The class offers a `constexpr` method called `ComputePllFraction()` to 
figure out the best values for a PLL fraction to generate a specific 
frequency. This is a simple brute force routine which approximates the 
best PLL **N/M** fraction to produce a target frequency.

For an easy to use solution, use `AnyPllVco<>` or `AnyPllVcoAuto<>`, 
depending on MCU and requirements to compute the PLL fraction. These are 
described next.


## The `AnyPllVco<>` template class

This is the most common *PLL calculator class*, since it embeds the PLL 
frequency constraints for your current target settings.

This template class have slight variation depending on the target 
hardware.


### <big>`AnyPllVco<>`</big> for the STM32F1 Devices

In the STM32F1 family this template class is embedded into the `AnyPll<>` 
template class, as the single possible PLL calculator and you don't have 
to bother declaring a data-type for it.  
But for the newer STM32 family members, this class needs to be explicitly 
declared and given as part of the `AnyPll<>` template instance arguments, 
and it will be used to compute the PLL divisors.


### <big>`AnyPllVco<>`</big> for the STM32L4 Devices

For the STM32L4 family,  and newer devices of the STM32 family an 
improved PLL is available that features an addition divisor and follows 
the formula:

```cpp
F_out = ((F_in / M) * N) / R;
```

This means, that the PLL core works like previously, a divisor followed 
by a frequency multiplier, but the final VCO frequency is then divided 
before producing the SYSCLK.

The template parameters for these newer PLL circuit are:

- `PllVcoAttr`: specifies a data-type used as base class build on top of 
the parameters compatible to the power mode that you are planning to use 
the PLL. This can be either `PllRange1` or `PllRange2`, which 
specifies the intended internal power supply level that the PLL will run. 
This is important because **Range 2** specifies a low power mode for 
battery supplied devices, lower regulator voltage and lower clock 
frequencies provides longer battery duration.  
Don't need to mention that VCO range is severely affected by this 
information. 
- `k_R`: specifies the output '/R' divisor that will be used. This 
divisor is one of `2`, `4`, `6` or `8` factor that divides the VCO output 
frequency to produce the **SYSCLK**.

Besides this, these devices can have other outputs with independent 
divisors to drive other hardware peripherals independently.

For example, you can adjust your VCO to **288 MHz** and obtain **72 MHz** 
(`/4`) for CPU clock and **48 MHz** (`/6`) for USB clock using a single
PLL circuit.

```cpp
using namespace Bmt;

// 8 MHz crystal
constexpr uint32_t kMyXtal = 8000000UL;
// 72 MHz desired SYSCLK
constexpr uint32_t kMySysClk = 72000000UL;

// The HSE drives the XTAL
typedef Clocks::AnyHse<kMyXtal> Hse;
// Calculator using '/R = 4' for PLLCLK/SYSCLK
typedef Clocks::AnyPllVco<Clocks::PllRange1, 4> PllCalculator;
// The Pll uses Hse and Calculator to obtain 72MHz
typedef Clocks::AnyPll<
    Hse,                // clock source used for the PLL
    kMySysClk,          // desired PLL output
    PllCalculator,      // calculator to obtain '/M', '/N' and '/R'
    true,               // enables the PLLCLK
    0,                  // do not enable the '/P' (PLLSAI2CLK) output
    6,                  // use '/Q = 6' to create 48 MHz for USB
    > Pll;

void main()
{
    // ...

    // This starts HSE, then setups and starts PLL
    Pll::Init();
    // Note that PLLCLK output needs to be switched into SYSCLK for
    // the MCU to profit. There is a class that makes life better,
    // see AnySycClk<> later on...

    // ...
}
```


### The <big>`AnyPllVcoAuto<>`</big> template class

This is another *PLL calculator class* similar to `AnyPllVco<>`, but it 
selects the lowest '/R' possible to produce the PLLCLK.
Unlike the example above, if the '/R' divisor has not to be a specific 
value this class is recommended as it will try the lowest possible PLL 
frequency for your output, which has the advantage of lowering power 
consumption.


# The `AnySycClk<>` template class

This is a class that binds all concepts shown before to configure the 
system clock.

This template has the following arguments:

- `ClockSource`: The clock source that should drive the SYSCLK signal. 
This is a template class like `AnyHse<>`, `AnyHsi<>` or `AnyPll<>`, 
already documented above.
- `kAhbPrs`: This argument is a divisor for the AHB bus, which directly 
controls CPU, memory and all other clock derivatives.
- `kApb1Prs`: This argument is a divisor for the APB1 bus. On many STM32 
devices this clock is slower than of the APB2 bus.
- `kApb2Prs`: This template argument is the divisor for the APB2 bus. 
Usually this provides clock for the high speed peripherals.
- `kRcOff`: This argument instruct the Init() method to deactivate the 
RC clock used during boot. If the RC clock is not meant to be used, this 
helps to reduce power consumption.
- `kClockOut`: This argument lets you switch a specific clock to the MCO 
pin of the MCU.  
Note that the Init() method does not configure the GPIO for the MCO 
function. This needs to be explicitly configured with the GPIO classes.
- `kMcoPrscl`: The clock output can be divided by the given factor.

This class works like a swiss knife since it configures almost any aspect 
of the clock tree and it was designed to interact with other classes so 
that they can compute baud rates and other timing aspects.

This is an example:

```cpp
namespace Bmt;

// 8 MHz crystal
constexpr uint32_t kMyXtal = 8000000UL;
// 72 MHz desired SYSCLK
constexpr uint32_t kMySysClk = 72000000UL;

// The HSE drives the XTAL
typedef Clocks::AnyHse<kMyXtal> Hse;
// Calculator using '/R = 4' for PLLCLK/SYSCLK
typedef Clocks::AnyPllVco<Clocks::PllRange1, 4> PllCalculator;
// The Pll uses Hse and Calculator to obtain 72MHz
typedef Clocks::AnyPll<
    Hse,                // clock source used for the PLL
    kMySysClk,          // desired PLL output
    PllCalculator,      // calculator to obtain '/M', '/N' and '/R'
    true,               // enables the PLLCLK
    0,                  // do not enable the '/P' (PLLSAI2CLK) output
    6,                  // use '/Q = 6' to create 48 MHz for USB
    > Pll;

typedef Clocks::AnySysClk<
    Pll,                // Uses the PLL as system clock
    AhbPrscl::k1,       // No divisor for thw AHB bus
    ApbPrscl::k2,       // 36 MHz for the APB1 bus
    ApbPrscl::k1,       // 72 MHz for the APB2 bus
    true,               // Turn RC clock off
    Mco::kSysClk,       // Configure MCO function to output the PLL frequency
    McoPrscl::k16       // 72 MHz / 16 = 4,5 MHz
    > SysClk;

void main()
{
    // ...

    // This starts HSE, then setups and starts PLL and initializes the 
    // clock tree
    SysClk::Init();

    // ...
}
```

